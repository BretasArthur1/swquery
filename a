File: swquery/src/errors.rs
use {reqwest, thiserror::Error};

#[derive(Debug, Error)]
pub enum SdkError {
    #[error("Invalid input: {0}")]
    InvalidInput(String),

    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),

    #[error("Parse error: {0}")]
    ParseError(String),

    #[error("HTTP error: {0}")]
    HttpError(#[from] reqwest::Error),

    #[error("Transformer error: {0}")]
    TransformerError(#[from] crate::llm::TransformerError),

    #[error("Network error occurred: {0}")]
    NetworkError(String),

    #[error("Wallet not found")]
    WalletNotFound,

    #[error("Failed to parse the query")]
    QueryParsingFailed,

    #[error("API request failed: {0}")]
    ApiRequestFailed(String),

    #[error("Unknown error")]
    Unknown,

    #[error("Unexpected error: {0}")]
    Unexpected(String),

    #[error("Failed to send request")]
    RequestFailed,
}

File: swquery/src/lib.rs
pub mod client;
pub mod errors;
pub mod llm;
pub mod models;
pub mod utils;

pub use client::SWqueryClient;

File: swquery/src/llm/mod.rs
mod transformer;

pub use transformer::{TransformerError, TransformerModel};

File: swquery/src/llm/transformer.rs
use {
    reqwest,
    serde::Deserialize,
    serde_json::{self, Value},
    std::collections::HashMap,
    thiserror::Error,
};

/// Tipo de entrada e saída do modelo.
type Input = Value;
type Output = String;

/// Erros que podem ocorrer durante o processo de transformação.
#[derive(Debug, Error)]
pub enum TransformerError {
    /// Erro de parsing do JSON de entrada.
    #[error("Failed to parse input as JSON: {0}")]
    ParseError(#[from] serde_json::Error),

    /// Erro se não encontrar o campo "inputUser" no JSON.
    #[error("Inference error: {0}")]
    InferenceError(String),
}

/// `TransformerModel` representa o modelo que extrai o "inputUser" do JSON
/// recebido.
pub struct TransformerModel {
    pub name: String,
    pub version: String,
    pub description: String,
    pub input: Vec<Input>,
    pub output: Vec<Output>,
    pub metadata: HashMap<String, String>,
}

impl TransformerModel {
    /// Cria uma nova instância do `TransformerModel`.
    pub fn new(
        name: String,
        version: String,
        description: String,
        input: Vec<Input>,
        output: Vec<Output>,
        metadata: HashMap<String, String>,
    ) -> Self {
        Self {
            name,
            version,
            description,
            input,
            output,
            metadata,
        }
    }

    /// Extrai o campo "inputUser" do JSON. Se não existir, retorna um
    /// `InferenceError`.
    fn run(&self, input: Input) -> Result<Output, TransformerError> {
        if let Some(user_input) = input.get("inputUser") {
            if let Some(user_str) = user_input.as_str() {
                Ok(user_str.to_string())
            } else {
                Err(TransformerError::InferenceError(
                    "'inputUser' field is not a string.".to_string(),
                ))
            }
        } else {
            Err(TransformerError::InferenceError(
                "No 'inputUser' field found in input JSON.".to_string(),
            ))
        }
    }

    /// `run_inference` recebe uma string JSON, parseia para `Input`, chama
    /// `run` para extrair o prompt do usuário e retorna esse prompt como
    /// `String`.
    pub fn run_inference(&self, input: &str) -> Result<String, TransformerError> {
        let input_val: Input = serde_json::from_str(input)?;
        let output_val = self.run(input_val)?;
        Ok(output_val)
    }

    /// Esta função recebe o prompt extraído e envia via POST para a rota do LLM
    /// Espera que o LLM retorne uma string (por exemplo, a query gerada).
    pub async fn send_prompt_to_llm(
        &self,
        prompt: &str,
    ) -> Result<QueryResponse, Box<dyn std::error::Error>> {
        let client = reqwest::Client::new();
        let resp = client
            .post("http://localhost:5500/agent/generate_query")
            .json(&serde_json::json!({"inputUser": prompt}))
            .send()
            .await?;

        match resp.status() {
            status if status.is_success() => {
                let response: QueryResponse = resp.json().await?;
                match response.result.status.as_str() {
                    "error" => Err(format!("LLM Error: {}", response.result.response).into()),
                    "success" => Ok(response),
                    _ => Err("Unknown response status".into()),
                }
            }
            status => Err(format!("Server returned status: {}", status).into()),
        }
    }
}

#[derive(Deserialize)]
pub struct QueryResponse {
    result: QueryResult,
    pub tokens: i64,
}

#[derive(Deserialize, Debug)]
struct QueryResult {
    pub response: String,
    pub status: String,
}

File: swquery/src/models/mod.rs
pub mod transactions;

pub use transactions::*;

File: swquery/src/models/transactions.rs
#![allow(non_snake_case)]
use {
    serde::{Deserialize, Serialize},
    serde_json::Value,
    std::collections::HashMap,
};

/// A representation of a response from the getSignaturesForAddress RPC.
#[derive(Debug, Deserialize, Serialize)]
pub struct GetSignaturesForAddressResponse {
    pub result: Vec<Signature>,
}

/// A transaction signature entry.
#[derive(Debug, Deserialize, Serialize)]
pub struct Signature {
    pub block_time: u64,
    pub confirmation_status: String,
    pub err: Value,
    pub memo: Option<String>,
    pub signature: String,
    pub slot: u64,
}

/// A recent transaction entry used by `getRecentTransactions`.
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RecentTransaction {
    pub signature: String,
    pub slot: u64,
    pub timestamp: u64,
    pub status: String,
}

/// Response structure for `getRecentTransactions`.
#[derive(Debug, Serialize, Deserialize)]
pub struct RecentTransactionsResponse {
    pub jsonrpc: String,
    pub result: Vec<RecentTransaction>,
    pub id: u64,
}

/// A single signature info object.
#[derive(Debug, Deserialize, Serialize)]
pub struct SignatureInfo {
    pub signature: String,
    pub slot: u64,
    pub blockTime: Option<u64>,
    pub confirmationStatus: String,
    pub err: Option<Value>,
}

/// Response structure for `getSignaturesForAddress` or similar.
#[derive(Debug, Deserialize, Serialize)]
pub struct SignaturesResponse {
    pub jsonrpc: String,
    pub result: Vec<SignatureInfo>,
    pub id: u64,
}

/// Represents an NFT or asset entry used by the `getAssetsByOwner`, etc.
#[derive(Debug, Deserialize, Serialize)]
pub struct Asset {
    pub id: String,
    pub content: Value,
    pub ownership: Value,
}

/// Response for asset-related RPCs.
#[derive(Debug, Deserialize, Serialize)]
pub struct AssetsResponse {
    pub jsonrpc: String,
    pub result: Vec<Asset>,
    pub id: String,
}

/// A generic RPC response format.
#[derive(Debug, Deserialize, Serialize)]
pub struct RpcResponse<T> {
    pub jsonrpc: String,
    pub result: T,
    pub id: Value,
}

/// Result for the getBalance RPC.
#[derive(Debug, Deserialize, Serialize)]
pub struct GetBalanceResult {
    pub value: u64,
}

/// Type alias for getBalance.
pub type GetBalanceResponse = RpcResponse<GetBalanceResult>;

/// Type alias for getBlockHeight.
pub type GetBlockHeightResponse = RpcResponse<u64>;

/// Represents the block production range for getBlockProduction.
#[derive(Debug, Deserialize, Serialize)]
pub struct BlockProductionRange {
    pub firstSlot: u64,
    pub lastSlot: u64,
}

/// Represents the result structure for getBlockProduction.
#[derive(Debug, Deserialize, Serialize)]
pub struct BlockProductionResult {
    pub byIdentity: HashMap<String, Vec<u64>>,
    pub range: BlockProductionRange,
}

/// Type alias for getBlockProduction.
pub type GetBlockProductionResponse = RpcResponse<BlockProductionResult>;

/// Represents the result structure for getBlockCommitment.
#[derive(Debug, Deserialize, Serialize)]
pub struct BlockCommitmentResult {
    pub commitment: Option<[u64; 2]>,
    pub totalStake: u64,
}

/// Type alias for getBlockCommitment.
pub type GetBlockCommitmentResponse = RpcResponse<BlockCommitmentResult>;

/// Type alias for getBlocks.
pub type GetBlocksResponse = RpcResponse<Vec<u64>>;

/// Type alias for getBlockTime.
pub type GetBlockTimeResponse = RpcResponse<Option<u64>>;

/// Represents a cluster node from getClusterNodes.
#[derive(Debug, Deserialize, Serialize)]
pub struct ClusterNode {
    pub pubkey: String,
    pub gossip: Option<String>,
    pub tpu: Option<String>,
    pub rpc: Option<String>,
    pub version: Option<String>,
    pub featureSet: Option<u64>,
    pub shredVersion: Option<u64>,
}

/// Type alias for getClusterNodes.
pub type GetClusterNodesResponse = RpcResponse<Vec<ClusterNode>>;

/// Represents epoch info for getEpochInfo.
#[derive(Debug, Deserialize, Serialize)]
pub struct EpochInfo {
    pub epoch: u64,
    pub slotIndex: u64,
    pub slotsInEpoch: u64,
    pub absoluteSlot: u64,
    pub blockHeight: u64,
    pub transactionCount: Option<u64>,
}

/// Type alias for getEpochInfo.
pub type GetEpochInfoResponse = RpcResponse<EpochInfo>;

/// Represents the epoch schedule structure for getEpochSchedule.
#[derive(Debug, Deserialize, Serialize)]
pub struct EpochSchedule {
    pub slotsPerEpoch: u64,
    pub leaderScheduleSlotOffset: u64,
    pub warmup: bool,
    pub firstNormalEpoch: u64,
    pub firstNormalSlot: u64,
}

/// Type alias for getEpochSchedule.
pub type GetEpochScheduleResponse = RpcResponse<EpochSchedule>;

/// Represents the fee for a given message in getFeeForMessage.
#[derive(Debug, Deserialize, Serialize)]
pub struct FeeForMessageValue {
    pub value: Option<u64>,
}

/// Type alias for getFeeForMessage.
pub type GetFeeForMessageResponse = RpcResponse<FeeForMessageValue>;

/// Type alias for getFirstAvailableBlock.
pub type GetFirstAvailableBlockResponse = RpcResponse<u64>;

/// Type alias for getGenesisHash.
pub type GetGenesisHashResponse = RpcResponse<String>;

/// Type alias for getHealth.
pub type GetHealthResponse = RpcResponse<String>;

/// Represents the highest snapshot slot for getHighestSnapshotSlot.
#[derive(Debug, Deserialize, Serialize)]
pub struct HighestSnapshotSlot {
    pub full: u64,
    pub incremental: u64,
}

/// Type alias for getHighestSnapshotSlot.
pub type GetHighestSnapshotSlotResponse = RpcResponse<HighestSnapshotSlot>;

/// Type alias for getIdentity.
pub type GetIdentityResponse = RpcResponse<String>;

/// Represents the inflation governor for getInflationGovernor.
#[derive(Debug, Deserialize, Serialize)]
pub struct InflationGovernor {
    pub foundation: f64,
    pub foundationTerm: f64,
    pub initial: f64,
    pub taper: f64,
    pub terminal: f64,
}

/// Type alias for getInflationGovernor.
pub type GetInflationGovernorResponse = RpcResponse<InflationGovernor>;

/// Represents the inflation rate info for getInflationRate.
#[derive(Debug, Deserialize, Serialize)]
pub struct InflationRate {
    pub epoch: u64,
    pub foundation: f64,
    pub total: f64,
    pub validator: f64,
}

/// Type alias for getInflationRate.
pub type GetInflationRateResponse = RpcResponse<InflationRate>;

/// Represents one of the largest accounts for getLargestAccounts.
#[derive(Debug, Deserialize, Serialize)]
pub struct LargestAccount {
    pub lamports: u64,
    pub address: String,
}

/// Type alias for getLargestAccounts.
pub type GetLargestAccountsResponse = RpcResponse<Vec<LargestAccount>>;

/// Represents the latest blockhash info for getLatestBlockhash.
#[derive(Debug, Deserialize, Serialize)]
pub struct LatestBlockhashResult {
    pub blockhash: String,
    pub lastValidBlockHeight: u64,
}

/// Type alias for getLatestBlockhash.
pub type GetLatestBlockhashResponse = RpcResponse<LatestBlockhashResult>;

/// Type alias for getLeaderSchedule (a map of leader to slots).
pub type GetLeaderScheduleResponse = RpcResponse<HashMap<String, Vec<u64>>>;

/// Type alias for getMaxRetransmitSlot.
pub type GetMaxRetransmitSlotResponse = RpcResponse<u64>;

/// Type alias for getMaxShredInsertSlot.
pub type GetMaxShredInsertSlotResponse = RpcResponse<u64>;

/// Type alias for getMinimumBalanceForRentExemption.
pub type GetMinimumBalanceForRentExemptionResponse = RpcResponse<u64>;

/// Represents account data for getProgramAccounts.
#[derive(Debug, Deserialize, Serialize)]
pub struct AccountData {
    pub lamports: u64,
    pub data: (String, String),
    pub owner: String,
    pub executable: bool,
    pub rentEpoch: u64,
}

/// A keyed account used in getProgramAccounts.
#[derive(Debug, Deserialize, Serialize)]
pub struct KeyedAccount {
    pub pubkey: String,
    pub account: AccountData,
}

/// Type alias for getProgramAccounts.
pub type GetProgramAccountsResponse = RpcResponse<Vec<KeyedAccount>>;

/// Represents a performance sample for getRecentPerformanceSamples.
#[derive(Debug, Deserialize, Serialize)]
pub struct PerformanceSample {
    pub slot: u64,
    pub numTransactions: u64,
    pub numSlots: u64,
    pub samplePeriodSecs: u64,
}

/// Type alias for getRecentPerformanceSamples.
pub type GetRecentPerformanceSamplesResponse = RpcResponse<Vec<PerformanceSample>>;

/// Type alias for getSlot.
pub type GetSlotResponse = RpcResponse<u64>;

/// Type alias for getSlotLeader.
pub type GetSlotLeaderResponse = RpcResponse<String>;

/// Represents stake activation info for getStakeActivation.
#[derive(Debug, Deserialize, Serialize)]
pub struct StakeActivation {
    pub state: String,
    pub active: u64,
    pub inactive: u64,
}

/// Type alias for getStakeActivation.
pub type GetStakeActivationResponse = RpcResponse<StakeActivation>;

/// Type alias for getStakeMinimumDelegation.
pub type GetStakeMinimumDelegationResponse = RpcResponse<u64>;

/// Represents supply values for getSupply.
#[derive(Debug, Deserialize, Serialize)]
pub struct SupplyValue {
    pub circulating: u64,
    pub nonCirculating: u64,
    pub nonCirculatingAccountsList: Vec<String>,
    pub total: u64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct SupplyResult {
    pub value: SupplyValue,
}

/// Type alias for getSupply.
pub type GetSupplyResponse = RpcResponse<SupplyResult>;

/// Represents a UI token amount in account balances.
#[derive(Debug, Deserialize, Serialize)]
pub struct UiTokenAmount {
    pub uiAmount: Option<f64>,
    pub amount: String,
    pub decimals: u8,
    pub uiAmountString: String,
}

/// Token balance result for getTokenAccountBalance.
#[derive(Debug, Deserialize, Serialize)]
pub struct TokenBalanceResult {
    pub value: UiTokenAmount,
}

/// Type alias for getTokenAccountBalance.
pub type GetTokenAccountBalanceResponse = RpcResponse<TokenBalanceResult>;

/// Represents a largest account for a token mint from getTokenLargestAccounts.
#[derive(Debug, Deserialize, Serialize)]
pub struct TokenLargestAccount {
    pub address: String,
    pub lamports: u64,
    pub uiAmount: Option<f64>,
    pub decimals: u8,
    pub uiAmountString: String,
}

/// Type alias for getTokenLargestAccounts.
pub type GetTokenLargestAccountsResponse = RpcResponse<Vec<TokenLargestAccount>>;

/// Represents token supply info from getTokenSupply.
#[derive(Debug, Deserialize, Serialize)]
pub struct TokenSupplyValue {
    pub amount: String,
    pub decimals: u8,
    pub uiAmount: Option<f64>,
    pub uiAmountString: String,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct TokenSupplyResult {
    pub value: TokenSupplyValue,
}

/// Type alias for getTokenSupply.
pub type GetTokenSupplyResponse = RpcResponse<TokenSupplyResult>;

/// Represents the metadata of a transaction.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TransactionMeta {
    pub slot: Option<u64>,
    pub err: Option<Value>,
    pub fee: Option<u64>,
    #[serde(default)]
    pub preBalances: Vec<u64>,
    #[serde(default)]
    pub postBalances: Vec<u64>,
    #[serde(default)]
    pub innerInstructions: Vec<Value>,
    #[serde(default)]
    pub logMessages: Vec<String>,
    #[serde(default)]
    pub preTokenBalances: Vec<Value>,
    #[serde(default)]
    pub postTokenBalances: Vec<Value>,
    #[serde(default)]
    pub rewards: Vec<Value>,
    #[serde(default)]
    pub status: Value,
}

/// Represents an encoded transaction.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct EncodedTransaction {
    #[serde(rename = "signatures")]
    pub signatures: Vec<String>,
    #[serde(rename = "message")]
    pub message: Value,
}

/// Represents the result of getTransaction.
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TransactionResult {
    pub blockTime: Option<u64>,
    pub meta: Option<TransactionMeta>,
    pub slot: u64,
    pub transaction: EncodedTransaction,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct GetTransactionResponse {
    pub jsonrpc: String,
    pub result: TransactionResult,
    pub id: u64,
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct FullTransaction {
    pub signature: String,
    pub slot: u64,
    pub timestamp: u64,
    pub status: String,
    pub details: Value, // Include the full transaction result
    pub token_metadata: HashMap<String, Value>,
}

/// Type alias for getTransactionCount.
pub type GetTransactionCountResponse = RpcResponse<u64>;

/// Represents the version info for getVersion.
#[derive(Debug, Deserialize, Serialize)]
pub struct VersionInfo {
    #[serde(rename = "solana-core")]
    pub solana_core: String,
}

/// Type alias for getVersion.
pub type GetVersionResponse = RpcResponse<VersionInfo>;

/// Represents a vote account info entry for getVoteAccounts.
#[derive(Debug, Deserialize, Serialize)]
pub struct VoteAccountInfo {
    pub votePubkey: String,
    pub nodePubkey: String,
    pub activatedStake: u64,
    pub epochVoteAccount: bool,
    pub commission: u8,
    #[serde(default)]
    pub lastVote: u64,
    #[serde(default)]
    pub epochCredits: Vec<Value>,
}

/// Represents the result of getVoteAccounts.
#[derive(Debug, Deserialize, Serialize)]
pub struct VoteAccountsResult {
    pub current: Vec<VoteAccountInfo>,
    pub delinquent: Vec<VoteAccountInfo>,
}

/// Type alias for getVoteAccounts.
pub type GetVoteAccountsResponse = RpcResponse<VoteAccountsResult>;

/// Represents the context for isBlockhashValid.
#[derive(Debug, Deserialize, Serialize)]
pub struct Context {
    pub slot: u64,
}

/// Represents the result of isBlockhashValid.
#[derive(Debug, Deserialize, Serialize)]
pub struct IsBlockhashValidResult {
    pub context: Context,
    pub value: bool,
}

/// Type alias for isBlockhashValid.
pub type IsBlockhashValidResponse = RpcResponse<IsBlockhashValidResult>;

/// Type alias for minimumLedgerSlot.
pub type MinimumLedgerSlotResponse = RpcResponse<u64>;

/// Represents account info for getAccountInfo.
#[derive(Debug, Deserialize, Serialize)]
pub struct AccountInfoValue {
    pub lamports: u64,
    pub data: (String, String),
    pub owner: String,
    pub executable: bool,
    pub rentEpoch: u64,
}

#[derive(Debug, Deserialize, Serialize)]
pub struct AccountInfoResult {
    pub value: Option<AccountInfoValue>,
}

/// Type alias for getAccountInfo.
pub type GetAccountInfoResponse = RpcResponse<AccountInfoResult>;

File: swquery/src/client.rs
use {
    crate::{errors::SdkError, models::*, utils::*},
    reqwest::Client,
    serde_json::{self, json, Value},
    std::time::Duration,
    tracing::error,
};

const AGENT_API_URL: &str = "http://localhost:5500/agent/generate-query";

/// Enum to represent the Solana network.
#[derive(Debug, Clone, Copy, Default)]
pub enum Network {
    #[default]
    Mainnet,
    Devnet,
}

/// SWqueryClient is the main entry point for using this SDK to interact with
/// the Solana RPC via the Helius API and a custom Agent API. It provides typed
/// methods for various RPC calls.
#[derive(Debug)]
pub struct SWqueryClient {
    /// The API key for the Agent server.
    pub openai_key: String,
    /// The Helius API key for RPC calls.
    pub helius_key: String,
    /// The timeout for requests.
    pub timeout: Duration,
    /// The network to use for Helius RPC calls.
    pub network: Network,
    /// A reusable reqwest client.
    client: Client,
}

impl SWqueryClient {
    /// Constructs a new SWqueryClient.
    ///
    /// # Arguments
    ///
    /// * `openai_api_key` - The API key for the agent.
    /// * `helius_api_key` - The API key for Helius RPC.
    /// * `timeout` - Optional request timeout, defaults to 5 seconds if None.
    /// * `network` - Optional network, defaults to Mainnet if None.
    ///
    /// # Returns
    ///
    /// A new instance of SWqueryClient.
    pub fn new(
        openai_key: String,
        helius_key: String,
        timeout: Option<Duration>,
        network: Option<Network>,
    ) -> Self {
        SWqueryClient {
            openai_key,
            helius_key,
            timeout: timeout.unwrap_or(Duration::from_secs(5)),
            network: network.unwrap_or_default(),
            client: Client::builder()
                .timeout(timeout.unwrap_or(Duration::from_secs(5)))
                .build()
                .expect("Failed to build reqwest client"),
        }
    }

    /// Returns the Helius RPC URL based on the selected network.
    fn get_helius_rpc_url(&self) -> String {
        match self.network {
            Network::Mainnet => format!(
                "https://mainnet.helius-rpc.com/?api-key={}",
                self.helius_key
            ),
            Network::Devnet => {
                format!("https://devnet.helius-rpc.com/?api-key={}", self.helius_key)
            }
        }
    }

    // /// Sends a query to the SWQuery Agent API, receives a response type and
    // /// parameters, and then invokes the appropriate RPC method based on the
    // pub async fn execute_generated_function(
    //     &self,
    //     filter_function: &str,
    //     transactions: Vec<FullTransaction>,
    // ) -> Result<Vec<FullTransaction>, SdkError> {
    //     // Prepare the WASM engine
    //     let engine = Engine::default();

    //     // Compile the filter function as a module
    //     let wasm_code = format!(
    //         r#"
    //         use serde_json::{{Value, json}};
    //         use crate::FullTransaction;
    //         pub fn filter(transactions: Vec<FullTransaction>) ->
    // Vec<FullTransaction> {{             {}
    //         }}
    //         "#,
    //         filter_function
    //     );

    //     let module = Module::new(&engine, wasm_code).map_err(|e| {
    //         SdkError::Unexpected(format!("Failed to compile WASM module: {}", e))
    //     })?;

    //     // Create a new store
    //     let mut store = Store::new(&engine, ());

    //     // Serialize the transactions into JSON
    //     let transactions_json = serde_json::to_string(&transactions).map_err(|e|
    // {         SdkError::Unexpected(format!("Failed to serialize transactions:
    // {}", e))     })?;

    //     // Define the function in WASM
    //     let instance = wasmtime::Instance::new(&mut store, &module,
    // &[]).map_err(|e| {         SdkError::Unexpected(format!("Failed to create
    // WASM instance: {}", e))     })?;

    //     // Call the function
    //     let filter_fn = instance.get_typed_func::<(String,), String>(&mut store,
    // "filter")         .map_err(|e| SdkError::Unexpected(format!("Failed to
    // retrieve 'filter' function: {}", e)))?;

    //     // Execute the filter function
    //     let filtered_transactions_json = filter_fn.call(&mut store,
    // transactions_json).map_err(|e| {         SdkError::Unexpected(format!("
    // Failed to execute 'filter': {}", e))     })?;

    //     // Deserialize the JSON result back into `Vec<FullTransaction>`
    //     let filtered_transactions: Vec<FullTransaction> =
    // serde_json::from_str(&filtered_transactions_json).map_err(|e| {
    //         SdkError::Unexpected(format!("Failed to deserialize filtered
    // transactions: {}", e))     })?;

    //     Ok(filtered_transactions)
    // }

    ///
    /// # Arguments
    ///
    /// * `input` - User input or query for the agent.
    /// * `pubkey` - The public key (address) related to the query.
    ///
    /// # Returns
    ///
    /// A JSON value representing the RPC response, or an error if something
    /// went wrong.
    pub async fn query(&self, input: &str, pubkey: &str) -> Result<Value, SdkError> {
        // Send the request to the Agent API
        let payload = json!({
            "inputUser": input,
            "address": pubkey
        });

        println!("Sending request to Agent API: {:#?}", payload);
        let response = self
            .client
            .post(AGENT_API_URL)
            .header("x-api-key", &self.openai_key)
            .json(&payload)
            .send()
            .await
            .map_err(|e| {
                error!("Failed to send request to Agent: {:?}", e);
                println!("Failed to send request to Agent: {:?}", e);
                SdkError::RequestFailed
            })?;

        if !response.status().is_success() {
            error!("Agent API returned error status: {}", response.status());
            return Err(SdkError::ApiRequestFailed(response.status().to_string()));
        }

        let response_text = response.text().await.map_err(|e| {
            error!("Failed to get response text from Agent: {}", e);
            SdkError::ParseError(e.to_string())
        })?;

        // Debug log the raw response
        println!("Raw response: {}", response_text);

        let result: Value = serde_json::from_str(&response_text).map_err(|e| {
            error!("Failed to parse Agent API response: {}", e);
            SdkError::ParseError(e.to_string())
        })?;
        println!("Parsed result: {:#?}", result);

        let response_type = result["result"]["response"]
            .as_str()
            .ok_or_else(|| SdkError::Unexpected("Missing response field".to_string()))?;
        println!("Response type: {}", response_type);

        let params = result["result"].get("params").ok_or_else(|| {
            SdkError::InvalidInput("Missing 'params' field in response.".to_string())
        })?;
        println!("Params: {:#?}", params);

        // Handle all the supported RPC calls based on response_type
        let mut response: serde_json::Value = serde_json::Value::Null;
        match response_type {
            "getRecentTransactions" => {
                let address = get_optional_str_param(params, "address").unwrap_or_default();
                if address.is_empty() {
                    return Err(SdkError::InvalidInput(
                        "Missing address parameter".to_string(),
                    ));
                }
                let days: u64 = get_optional_u64_param(params, "days", 1);

                let response_unparsed = self.get_recent_transactions(address, days).await?;
                response = to_value_response(response_unparsed).unwrap();
            }
            "getSignaturesForAddressPeriod" => {
                let address = get_optional_str_param(params, "address").unwrap_or_default();
                if address.is_empty() {
                    return Err(SdkError::InvalidInput(
                        "Missing address parameter".to_string(),
                    ));
                }

                let from = get_optional_u64_param(params, "from", 0);
                let to = get_optional_u64_param(params, "to", 0);

                let response_unparsed = self
                    .get_signatures_for_address(address, Some(from), Some(to))
                    .await?;
                response = to_value_response(response_unparsed).unwrap();
            }
            "getSignaturesForAddress" => {
                let address = get_required_str_param(params, "address")?;
                let response_unparsed =
                    self.get_signatures_for_address(address, None, None).await?;
                response = to_value_response(response_unparsed).unwrap();
            }
            // "getAssetsByOwner" => {
            //     let owner = get_required_str_param(params, "owner")?;
            //     let response = self.get_assets_by_owner(owner).await?;
            //     to_value_response(response)
            // }
            // "getAssetsByCreator" => {
            //     let creator = get_required_str_param(params, "creator")?;
            //     let response = self.get_assets_by_creator(creator).await?;
            //     to_value_response(response)
            // }
            // "getAssetsByAuthority" => {
            //     let authority = get_required_str_param(params, "authority")?;
            //     let response = self.get_assets_by_authority(authority).await?;
            //     to_value_response(response)
            // }
            // "getSignaturesForAsset" => {
            //     let asset = get_required_str_param(params, "asset")?;
            //     let response = self.get_signatures_for_asset(asset).await?;
            //     to_value_response(response)
            // }
            // "getBalance" => {
            //     let address = get_required_str_param(params, "address")?;
            //     let response = self.get_balance(address).await?;
            //     to_value_response(response)
            // }
            // "getBlockHeight" => {
            //     let response = self.get_block_height().await?;
            //     to_value_response(response)
            // }
            // "getBlockProduction" => {
            //     let response = self.get_block_production().await?;
            //     to_value_response(response)
            // }
            // "getBlockCommitment" => {
            //     let slot = get_required_u64_param(params, "slot")?;
            //     let response = self.get_block_commitment(slot).await?;
            //     to_value_response(response)
            // }
            // "getBlocks" => {
            //     let start_slot = get_required_u64_param(params, "start_slot")?;
            //     let end_slot = get_optional_u64_param(params, "end_slot", start_slot);
            //     let response = self.get_blocks(start_slot, end_slot).await?;
            //     to_value_response(response)
            // }
            // "getBlockTime" => {
            //     let slot = get_required_u64_param(params, "slot")?;
            //     let response = self.get_block_time(slot).await?;
            //     to_value_response(response)
            // }
            // "getClusterNodes" => {
            //     let response = self.get_cluster_nodes().await?;
            //     to_value_response(response)
            // }
            // "getEpochInfo" => {
            //     let response = self.get_epoch_info().await?;
            //     to_value_response(response)
            // }
            // "getEpochSchedule" => {
            //     let response = self.get_epoch_schedule().await?;
            //     to_value_response(response)
            // }
            // "getFeeForMessage" => {
            //     let message = get_required_str_param(params, "message")?;
            //     let response = self.get_fee_for_message(message).await?;
            //     to_value_response(response)
            // }
            // "getFirstAvailableBlock" => {
            //     let response = self.get_first_available_block().await?;
            //     to_value_response(response)
            // }
            // "getGenesisHash" => {
            //     let response = self.get_genesis_hash().await?;
            //     to_value_response(response)
            // }
            // "getHealth" => {
            //     let response = self.get_health().await?;
            //     to_value_response(response)
            // }
            // "getHighestSnapshotSlot" => {
            //     let response = self.get_highest_snapshot_slot().await?;
            //     to_value_response(response)
            // }
            // "getIdentity" => {
            //     let response = self.get_identity().await?;
            //     to_value_response(response)
            // }
            // "getInflationGovernor" => {
            //     let response = self.get_inflation_governor().await?;
            //     to_value_response(response)
            // }
            // "getInflationRate" => {
            //     let response = self.get_inflation_rate().await?;
            //     to_value_response(response)
            // }
            // "getLargestAccounts" => {
            //     let response = self.get_largest_accounts().await?;
            //     to_value_response(response)
            // }
            // "getLatestBlockhash" => {
            //     let response = self.get_latest_blockhash().await?;
            //     to_value_response(response)
            // }
            // "getLeaderSchedule" => {
            //     let response = self.get_leader_schedule().await?;
            //     to_value_response(response)
            //  }
            // "getMaxRetransmitSlot" => {
            //     let response = self.get_max_retransmit_slot().await?;
            //     to_value_response(response)
            // }
            // "getMaxShredInsertSlot" => {
            //     let response = self.get_max_shred_insert_slot().await?;
            //     to_value_response(response)
            // }
            // "getMinimumBalanceForRentExemption" => {
            //     let data_len = get_required_u64_param(params, "data_len")?;
            //     let response = self
            //         .get_minimum_balance_for_rent_exemption(data_len)
            //         .await?;
            //     to_value_response(response)
            // }
            // "getProgramAccounts" => {
            //     let program_id = get_required_str_param(params, "program_id")?;
            //     let response = self.get_program_accounts(program_id).await?;
            //     to_value_response(response)
            // }
            // "getRecentPerformanceSamples" => {
            //     let limit = get_optional_u64_param(params, "limit", 10);
            //     let response = self.get_recent_performance_samples(limit).await?;
            //     to_value_response(response)
            // }
            // "getSlot" => {
            //     let response = self.get_slot().await?;
            //     to_value_response(response)
            // }
            // "getSlotLeader" => {
            //     let response = self.get_slot_leader().await?;
            //     to_value_response(response)
            // }
            // "getStakeActivation" => {
            //     let account = get_required_str_param(params, "account")?;
            //     let epoch = params["epoch"].as_u64();
            //     let response = self.get_stake_activation(account, epoch).await?;
            //     to_value_response(response)
            // }
            // "getStakeMinimumDelegation" => {
            //     let response = self.get_stake_minimum_delegation().await?;
            //     to_value_response(response)
            // }
            // "getSupply" => {
            //     let response = self.get_supply().await?;
            //     to_value_response(response)
            // }
            // "getTokenAccountBalance" => {
            //     let pubkey = get_required_str_param(params, "pubkey")?;
            //     let response = self.get_token_account_balance(pubkey).await?;
            //     to_value_response(response)
            // }
            // "getTokenLargestAccounts" => {
            //     let mint = get_required_str_param(params, "mint")?;
            //     let response = self.get_token_largest_accounts(mint).await?;
            //     to_value_response(response)
            // }
            // "getTokenSupply" => {
            //     let mint = get_required_str_param(params, "mint")?;
            //     let response = self.get_token_supply(mint).await?;
            //     to_value_response(response)
            // }
            // "getTransaction" => {
            //     let signature = get_required_str_param(params, "signature")?;
            //     let response = self.get_transaction(signature).await?;
            //     to_value_response(response)
            // }
            // "getTransactionCount" => {
            //     let response = self.get_transaction_count().await?;
            //     to_value_response(response)
            // }
            // "getVersion" => {
            //     let response = self.get_version().await?;
            //     to_value_response(response)
            // }
            // "getVoteAccounts" => {
            //     let response = self.get_vote_accounts().await?;
            //     to_value_response(response)
            // }
            // "isBlockhashValid" => {
            //     let blockhash = get_required_str_param(params, "blockhash")?;
            //     let response = self.is_blockhash_valid(blockhash).await?;
            //     to_value_response(response)
            // }
            // "minimumLedgerSlot" => {
            //     let response = self.minimum_ledger_slot().await?;
            //     to_value_response(response)
            // }
            // "getAccountInfo" => {
            //     let address = get_required_str_param(params, "address")?;
            //     let response = self.get_account_info(address).await?;
            //     to_value_response(response)
            // }
            _ => {
                return Err(SdkError::Unexpected(format!(
                    "Unsupported method: {}",
                    response_type
                )))
            }
        };

        // if let Some(filter_function) = params.get("filter_function") {
        //     let filter_function = filter_function.as_str().ok_or_else(|| {
        //         SdkError::Unexpected("Filter function is not a string".to_string())
        //     })?;

        //     println!("Filter function: {:#?}", filter_function);

        //     let transactions = response
        //         .as_array()
        //         .ok_or_else(|| SdkError::Unexpected("Response is not an
        // array".to_string()))?         .iter()
        //         .map(|t| serde_json::from_value(t.clone()).unwrap())
        //         .collect::<Vec<FullTransaction>>();

        //     let filtered_transactions =
        // self.execute_generated_function(filter_function, transactions)
        //         .await?;

        //     println!("Filtered transactions: {:#?}", filtered_transactions);
        // }

        Ok(response)
    }

    /// Fetch recent transactions for the last 'n' days using Helius RPC.
    /// This method bypasses `helius_rpc_call` for demonstration, but could be
    /// refactored.
    pub async fn get_recent_transactions(
        &self,
        address: &str,
        days: u64,
    ) -> Result<Vec<FullTransaction>, SdkError> {
        validate_address(address)?;

        // Calculate timestamp range
        let now = chrono::Utc::now().timestamp();
        let from_timestamp = now - (days as i64 * 24 * 60 * 60);

        let url = self.get_helius_rpc_url();

        // Get signatures
        let signatures_response = get_signatures(&self.client, &url, address).await?;
        println!("Fetched {} signatures", signatures_response.result.len());

        // Process signatures and get transaction details
        let mut transactions = Vec::new();
        for signature_info in signatures_response.result {
            // Get block time
            let block_time = if let Some(bt) = signature_info.blockTime {
                bt
            } else {
                get_block_time(&self.client, &url, signature_info.slot).await?
            };

            // Filter by timestamp
            if !is_within_timerange(block_time, Some(from_timestamp as u64), None) {
                continue;
            }

            // Get full transaction details
            match get_transaction_details_with_info(
                &self.client,
                &url,
                &signature_info.signature,
                &address,
            )
            .await
            {
                Ok(transaction) => transactions.push(transaction),
                Err(e) => eprintln!("Error getting transaction details: {}", e),
            }
        }

        println!("Total transactions fetched: {}", transactions.len());
        Ok(transactions)
    }

    // /// Fetch signatures for a specific address within a given time period.
    async fn get_signatures_for_address_period(
        &self,
        address: &str,
        from: u64,
        to: u64,
    ) -> Result<SignaturesResponse, SdkError> {
        if address.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Address cannot be empty".to_string(),
            ));
        }

        let url = self.get_helius_rpc_url();
        let payload = json!({
            "jsonrpc": "2.0",
            "id": 1,
            "method": "getSignaturesForAddress",
            "params": [
                address,
                {
                    "before": to,
                    "after": from,
                    "commitment": "finalized"
                }
            ]
        });

        let response = self
            .client
            .post(&url)
            .json(&payload)
            .send()
            .await
            .map_err(|e| SdkError::NetworkError(e.to_string()))?;

        if response.status().is_success() {
            let result: SignaturesResponse = response
                .json()
                .await
                .map_err(|e| SdkError::Unexpected(format!("Failed to parse response: {}", e)))?;
            Ok(result)
        } else {
            Err(SdkError::ApiRequestFailed(response.status().to_string()))
        }
    }

    /// Fetch transaction signatures for a specific address.
    async fn get_signatures_for_address(
        &self,
        address: &str,
        from: Option<u64>,
        to: Option<u64>,
    ) -> Result<SignaturesResponse, SdkError> {
        if address.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Address cannot be empty".to_string(),
            ));
        }

        let url = self.get_helius_rpc_url();

        // Get signatures using helper
        let mut signatures_response = get_signatures(&self.client, &url, address).await?;

        // Filter signatures
        let mut filtered_signatures = Vec::new();
        for signature_info in signatures_response.result {
            let block_time = if let Some(bt) = signature_info.blockTime {
                bt
            } else {
                // Get block time using helper
                get_block_time(&self.client, &url, signature_info.slot).await?
            };

            // Apply timestamp filters
            let mut include_signature = true;

            if let Some(from_timestamp) = from {
                if block_time < from_timestamp {
                    include_signature = false;
                }
            }

            if let Some(to_timestamp) = to {
                if block_time > to_timestamp {
                    include_signature = false;
                }
            }

            if include_signature {
                filtered_signatures.push(signature_info);
            }
        }

        signatures_response.result = filtered_signatures;
        println!(
            "Total filtered signatures: {}",
            signatures_response.result.len()
        );

        Ok(signatures_response)
    }

    //make_rpc_call(&self.client,"getAssetsByOwner", "getAssetsByOwner",
    // params).await

    // /// Fetch assets owned by a given address.
    async fn get_assets_by_owner(&self, owner: &str) -> Result<AssetsResponse, SdkError> {
        if owner.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Owner address cannot be empty".to_string(),
            ));
        }

        let params = json!([owner, {"page": 1}]);
        make_rpc_call(&self.client, "getAssetsByOwner", "getAssetsByOwner", params).await
    }

    /// Fetch assets associated with a given creator.
    async fn get_assets_by_creator(&self, creator: &str) -> Result<AssetsResponse, SdkError> {
        if creator.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Creator cannot be empty".to_string(),
            ));
        }
        let params = json!([creator, { "page": 1 }]);
        make_rpc_call(
            &self.client,
            "getAssetsByCreator",
            "getAssetsByCreator",
            params,
        )
        .await
    }

    /// Fetch assets associated with a given authority.
    async fn get_assets_by_authority(&self, authority: &str) -> Result<AssetsResponse, SdkError> {
        if authority.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Authority cannot be empty".to_string(),
            ));
        }
        let params = json!([authority, { "page": 1 }]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getAssetsByAuthority",
            params,
        )
        .await
    }

    /// Fetch transaction signatures for a specific asset.
    async fn get_signatures_for_asset(&self, asset: &str) -> Result<SignaturesResponse, SdkError> {
        if asset.trim().is_empty() {
            return Err(SdkError::InvalidInput("Asset cannot be empty".to_string()));
        }
        let params = json!([asset]);

        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getSignaturesForAsset",
            params,
        )
        .await
    }

    /// Fetch the balance for a given address.
    async fn get_balance(&self, address: &str) -> Result<GetBalanceResponse, SdkError> {
        if address.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Address cannot be empty".to_string(),
            ));
        }
        let params = json!([address]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getBalance",
            params,
        )
        .await
    }

    /// Fetch the block height.
    async fn get_block_height(&self) -> Result<GetBlockHeightResponse, SdkError> {
        let params = json!([]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getBlockHeight",
            params,
        )
        .await
    }

    /// Fetch block production.
    async fn get_block_production(&self) -> Result<GetBlockProductionResponse, SdkError> {
        let params = json!([]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getBlockProduction",
            params,
        )
        .await
    }

    /// Fetch block commitment for a given slot.
    async fn get_block_commitment(
        &self,
        slot: u64,
    ) -> Result<GetBlockCommitmentResponse, SdkError> {
        let params = json!([slot]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getBlockCommitment",
            params,
        )
        .await
    }

    /// Fetch blocks within a given slot range.
    async fn get_blocks(
        &self,
        start_slot: u64,
        end_slot: u64,
    ) -> Result<GetBlocksResponse, SdkError> {
        let params = if start_slot == end_slot {
            json!([start_slot])
        } else {
            json!([start_slot, end_slot])
        };
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getBlocks",
            params,
        )
        .await
    }

    /// Fetch block time for a given slot.
    async fn get_block_time(&self, slot: u64) -> Result<GetBlockTimeResponse, SdkError> {
        let params = json!([slot]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getBlockTime",
            params,
        )
        .await
    }

    /// Fetch the cluster nodes.
    async fn get_cluster_nodes(&self) -> Result<GetClusterNodesResponse, SdkError> {
        let params = json!([]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getClusterNodes",
            params,
        )
        .await
    }

    /// Fetch the epoch schedule.
    async fn get_epoch_info(&self) -> Result<GetEpochInfoResponse, SdkError> {
        let params = json!([]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getEpochInfo",
            params,
        )
        .await
    }

    /// Fetch the epoch schedule.
    async fn get_supply(&self) -> Result<GetSupplyResponse, SdkError> {
        let params = json!([]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getSupply",
            params,
        )
        .await
    }

    /// Fetch the fee for a given message.
    async fn get_token_account_balance(
        &self,
        pubkey: &str,
    ) -> Result<GetTokenAccountBalanceResponse, SdkError> {
        if pubkey.trim().is_empty() {
            return Err(SdkError::InvalidInput("Pubkey cannot be empty".to_string()));
        }
        let params = json!([pubkey]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getTokenAccountBalance",
            params,
        )
        .await
    }

    /// Fetch the fee for a given message.
    async fn get_transaction(&self, signature: &str) -> Result<GetTransactionResponse, SdkError> {
        if signature.trim().is_empty() {
            return Err(SdkError::InvalidInput(
                "Signature cannot be empty".to_string(),
            ));
        }
        let params = json!([signature]);
        make_rpc_call(
            &self.client,
            &self.get_helius_rpc_url(),
            "getTransaction",
            params,
        )
        .await
    }
}

File: swquery/src/utils.rs
use {
    crate::{errors::SdkError, models::*},
    reqwest::Client,
    serde::de::DeserializeOwned,
    serde_json::{json, Value},
    solana_sdk::{native_token::LAMPORTS_PER_SOL, pubkey::Pubkey},
    std::{
        collections::{HashMap, HashSet},
        str::FromStr,
    },
};

const METAPLEX_PROGRAM_ID: &str = "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s";

// Helper functions for parameter extraction
pub fn get_required_str_param<'a>(
    params: &'a serde_json::Value,
    field: &str,
) -> Result<&'a str, SdkError> {
    params[field]
        .as_str()
        .ok_or_else(|| SdkError::InvalidInput(format!("Missing {} parameter", field)))
}

pub fn get_optional_str_param<'a>(params: &'a serde_json::Value, field: &str) -> Option<&'a str> {
    params[field].as_str()
}

pub fn get_optional_u64_param(params: &serde_json::Value, field: &str, default: u64) -> u64 {
    params[field].as_u64().unwrap_or(default)
}

pub fn get_required_u64_param(params: &serde_json::Value, field: &str) -> Result<u64, SdkError> {
    params[field]
        .as_u64()
        .ok_or_else(|| SdkError::InvalidInput(format!("Missing {} parameter", field)))
}

// Helper to serialize response to Value
pub fn to_value_response<T: serde::Serialize>(response: T) -> Result<serde_json::Value, SdkError> {
    serde_json::to_value(response).map_err(|e| SdkError::Unexpected(e.to_string()))
}

/// Helper to validate address input
pub fn validate_address(address: &str) -> Result<(), SdkError> {
    if address.trim().is_empty() {
        return Err(SdkError::InvalidInput(
            "Address cannot be empty".to_string(),
        ));
    }
    Ok(())
}

/// Helper to filter by timestamp
pub fn is_within_timerange(timestamp: u64, from: Option<u64>, to: Option<u64>) -> bool {
    let mut include = true;

    if let Some(from_ts) = from {
        if timestamp < from_ts {
            include = false;
        }
    }

    if let Some(to_ts) = to {
        if timestamp > to_ts {
            include = false;
        }
    }

    include
}

/// Makes a generic RPC call
pub async fn make_rpc_call<T: DeserializeOwned>(
    client: &Client,
    url: &str,
    method: &str,
    params: Value,
) -> Result<T, SdkError> {
    let payload = json!({
        "jsonrpc": "2.0",
        "id": 1,
        "method": method,
        "params": params
    });

    let response = client
        .post(url)
        .json(&payload)
        .send()
        .await
        .map_err(|e| SdkError::NetworkError(e.to_string()))?;

    if !response.status().is_success() {
        return Err(SdkError::ApiRequestFailed(response.status().to_string()));
    }

    response
        .json()
        .await
        .map_err(|e| SdkError::ParseError(e.to_string()))
}

/// Helper to get block time for a slot
pub async fn get_block_time(client: &Client, url: &str, slot: u64) -> Result<u64, SdkError> {
    let block_time_payload = json!([slot]);

    let response: GetBlockTimeResponse =
        make_rpc_call(client, url, "getBlockTime", block_time_payload).await?;

    Ok(response.result.unwrap_or(0))
}

/// Helper to get signatures for address
pub async fn get_signatures(
    client: &Client,
    url: &str,
    address: &str,
) -> Result<SignaturesResponse, SdkError> {
    let payload = json!([
        address,
        { "commitment": "finalized" }
    ]);

    make_rpc_call(client, url, "getSignaturesForAddress", payload).await
}

pub async fn get_balance(
    client: &Client,
    url: &str,
    address: &str,
) -> Result<SignaturesResponse, SdkError> {
    let payload = json!([address]);

    make_rpc_call(client, url, "getBalance", payload).await
}

/// Helper to get transaction details
pub async fn get_transaction_details(
    client: &Client,
    url: &str,
    signature: &str,
) -> Result<GetTransactionResponse, SdkError> {
    let payload = json!([
        signature,
        {
            "encoding": "json",
            "maxSupportedTransactionVersion": 0
        }
    ]);

    make_rpc_call(client, url, "getTransaction", payload).await
}

pub async fn get_transaction_details_with_info(
    client: &Client,
    url: &str,
    signature: &str,
    wallet_address: &str,
) -> Result<FullTransaction, SdkError> {
    let response = get_transaction_details(client, url, signature).await?;
    let transaction_result = response.result;

    let mut token_metadata_map = HashMap::new();
    let mut transfers = Vec::new();
    let mut fee_payer = None;
    let mut fee_amount = 0;

    if let Some(meta) = &transaction_result.meta {
        // Determine fee payer and fees
        fee_amount = meta.fee.unwrap_or(0);
        if let Some(inner_instructions) = meta.innerInstructions.get(0) {
            if let Some(fee_payer_key) = inner_instructions["accountKeys"][0].as_str() {
                fee_payer = Some(fee_payer_key.to_string());
            }
        }

        let mints: HashSet<String> = meta
            .postTokenBalances
            .iter()
            .chain(meta.preTokenBalances.iter())
            .filter_map(|balance| balance.get("mint")?.as_str().map(|s| s.to_string()))
            .collect();

        // Fetch metadata for each mint
        for mint in mints {
            if let Ok(metadata) = get_asset_metadata(client, url, &mint).await {
                token_metadata_map.insert(mint.clone(), metadata);
            }
        }

        // Track transfers for the user's wallet
        let mut account_balance_map = HashMap::new();

        for balance in &meta.preTokenBalances {
            if let (Some(account), Some(mint)) = (
                balance.get("owner").and_then(|v| v.as_str()),
                balance.get("mint").and_then(|v| v.as_str()),
            ) {
                let amount = balance["uiTokenAmount"]["uiAmount"].as_f64().unwrap_or(0.0);
                account_balance_map.insert((account.to_string(), mint.to_string()), -amount);
            }
        }

        for balance in &meta.postTokenBalances {
            if let (Some(account), Some(mint)) = (
                balance.get("owner").and_then(|v| v.as_str()),
                balance.get("mint").and_then(|v| v.as_str()),
            ) {
                let amount = balance["uiTokenAmount"]["uiAmount"].as_f64().unwrap_or(0.0);
                *account_balance_map
                    .entry((account.to_string(), mint.to_string()))
                    .or_insert(0.0) += amount;
            }
        }

        // Filter transfers for the user's wallet
        for ((account, mint), delta) in account_balance_map {
            if account == wallet_address && delta != 0.0 {
                transfers.push(json!({
                    "mint": mint,
                    "amount": format!("{:.6}", delta.abs()),
                    "decimals": 6,
                    "metadata": token_metadata_map.get(&mint),
                    "direction": if delta > 0.0 { "in" } else { "out" },
                }));
            }
        }

        // Handle SOL transfers
        let mut total_sol_change = 0.0;
        for (pre_sol, post_sol) in meta.preBalances.iter().zip(meta.postBalances.iter()) {
            let amount_diff = (*post_sol as f64 - *pre_sol as f64) / LAMPORTS_PER_SOL as f64;
            if amount_diff != 0.0 {
                if amount_diff > 0.0 {
                    total_sol_change += amount_diff;
                } else {
                    total_sol_change += amount_diff;
                }
            }
        }

        if total_sol_change != 0.0 {
            transfers.push(json!({
                "mint": "SOL",
                "amount": format!("{:.9}", total_sol_change.abs()),
                "decimals": 9,
                "metadata": null,
                "direction": if total_sol_change > 0.0 { "in" } else { "out" },
            }));
        }
    }

    Ok(FullTransaction {
        signature: transaction_result.transaction.signatures[0].clone(),
        slot: transaction_result.slot,
        timestamp: transaction_result.blockTime.unwrap_or_default(),
        status: transaction_result
            .meta
            .as_ref()
            .map_or("unknown".to_string(), |m| {
                if m.err.is_some() { "failed" } else { "success" }.to_string()
            }),
        details: json!({
            "fee_payer": fee_payer,
            "fee_amount": fee_amount,
            "transfers": transfers,
        }),
        token_metadata: token_metadata_map,
    })
}

pub async fn get_asset_metadata(client: &Client, url: &str, mint: &str) -> Result<Value, SdkError> {
    let payload = json!([mint]);
    let response: Value = make_rpc_call(client, url, "getAsset", payload).await?;

    if let Some(result) = response.get("result") {
        match result {
            Value::Array(assets) if !assets.is_empty() => {
                Ok(assets[0].get("content").cloned().unwrap_or_default())
            }
            Value::Object(_) => {
                // If result is a single object, return it directly
                Ok(result.get("content").cloned().unwrap_or_default())
            }
            _ => Err(SdkError::Unexpected(format!(
                "Unexpected asset format for mint: {}",
                mint
            ))),
        }
    } else {
        Err(SdkError::Unexpected(format!(
            "No metadata found for mint: {}",
            mint
        )))
    }
}

fn get_metadata_account(mint: &Pubkey) -> Pubkey {
    let metaplex_program_id = Pubkey::from_str(METAPLEX_PROGRAM_ID).unwrap();
    let seeds = &[b"metadata", metaplex_program_id.as_ref(), mint.as_ref()];
    Pubkey::find_program_address(seeds, &metaplex_program_id).0
}

pub async fn get_token_account_balance(
    client: &Client,
    url: &str,
    address: &str,
) -> Result<SignaturesResponse, SdkError> {
    let payload = json!([address]);

    make_rpc_call(client, url, "getBalance", payload).await
}

/// Extracts the total amount from a transaction's details.
///
/// # Arguments
///
/// * `details` - The `Value` containing transaction details.
///
/// # Returns
///
/// The total amount transferred as a `f64`.
pub fn extract_total_amount(details: &serde_json::Value) -> f64 {
    details["transfers"]
        .as_array()
        .unwrap_or(&vec![])
        .iter()
        .map(|transfer| {
            transfer["amount"]
                .as_str()
                .unwrap_or("0")
                .parse::<f64>()
                .unwrap_or(0.0)
        })
        .sum()
}

